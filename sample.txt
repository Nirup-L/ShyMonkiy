let earliestTimestamp = Infinity;
const messageMap = {};
const batch_size = 12;
let lastKnownDate = "";
chatWindow.addEventListener("scroll", () => {
  if (chatWindow.scrollTop === 0) {
    console.log(earliestTimestamp);
    loadPreviousMessages(earliestTimestamp);
  }
});


function loadInitialMessages(callback = () => {}) {
  const chatWindow = document.getElementById("chatWindow");
  chatWindow.innerHTML = "";

  const ref = db.ref("messages").orderByChild("timestamp").limitToLast(batch_size);
  ref.off();

  let count = 0;
  let lastDate = "";
  ref.on("child_added", snapshot => {
    const id = snapshot.key;
    const msg = snapshot.val();
    const dateStr = formatChatDate(msg.timestamp);

    if (msg.timestamp < earliestTimestamp) {
      earliestTimestamp = msg.timestamp;
      lastKnownDate = dateStr;
      lastDate = lastKnownDate;
      console.log("initial inside timestamp:", lastKnownDate);
      console.log(earliestTimestamp);
    }

    if (dateStr !== lastDate && count > 0) {
      lastDate = dateStr;
      const separator = document.createElement("div");
      separator.className = "date-separator text-center my-2 text-muted";
      separator.innerText = dateStr;
      chatWindow.appendChild(separator);
      console.log("initial inside:", lastKnownDate);
    }

    const div = createMessageElement(msg, id);
    messageMap[id] = div;
    chatWindow.appendChild(div);

    if (msg.sender !== currentUser) {
      markAsSeen(id);
    }

    count++;
    scrollToBottom();
    callback();
  });

  ref.on("child_changed", snapshot => {
    const id = snapshot.key;
    const msg = snapshot.val();

    const oldDiv = messageMap[id];
    if (oldDiv) {
      const newDiv = createMessageElement(msg, id);
      chatWindow.replaceChild(newDiv, oldDiv);
      messageMap[id] = newDiv;
      scrollToBottom();
    }
  });

  // This log runs before any child_added events fire
  console.log("initial:", lastKnownDate);
}

function listenForMessages(callback = () => {}) {
  loadInitialMessages(callback);
}


function loadPreviousMessages(earliestTimeStamp, callback = () => {}) {
  const ref = db
    .ref("messages")
    .orderByChild("timestamp")
    .endAt(earliestTimeStamp - 1)
    .limitToLast(batch_size);

  ref.once("value", snapshot => {
    const messages = [];
    let newEarliest = earliestTimestamp;

    snapshot.forEach(child => {
      const id = child.key;
      const msg = child.val();
      messages.push({ id, ...msg });

      if (msg.timestamp < newEarliest) {
        newEarliest = msg.timestamp;
      }
    });

    earliestTimestamp = newEarliest;

    let count = 0;
    messages.reverse().forEach(({ id, ...msg }) => {
      const dateStr = formatChatDate(msg.timestamp);
      count++;

      if (dateStr !== lastKnownDate && count < batch_size) {
        const separator = document.createElement("div");
        separator.className = "date-separator text-center my-2 text-muted";
        separator.innerText = lastKnownDate;
        lastKnownDate = dateStr;
        chatWindow.insertBefore(separator, chatWindow.firstChild);
      }

      const div = createMessageElement(msg, id);
      chatWindow.insertBefore(div, chatWindow.firstChild);
      messageMap[id] = div;
    });

    console.log("previous:", lastKnownDate);
    callback();
  });
}
